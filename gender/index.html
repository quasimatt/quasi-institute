<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Gender Draft</title>
  <style>
    :root { --page-max: 1000px; } /* cap desktop width if you want */
    html, body { margin: 0; background:#000; color:#fff; }
    #viewer { margin: 0 auto; max-width: var(--page-max); }
    .page {
      padding: 12px 0;
      display: block;
      width: 100vw;          /* full width on mobile */
      max-width: var(--page-max);
      margin: 0 auto;
    }
    canvas {
      width: 100%;           /* responsive fit-to-width */
      height: auto;
      display: block;
      background: #111;      /* behind transparent pages */
    }
    /* Optional: show a tiny loading bar at top on slow PDFs */
    #loader {
      position: fixed; top: 0; left: 0; right: 0; height: 2px;
      background: linear-gradient(90deg, #88c, #9cf, #88c);
      animation: load 1s linear infinite; opacity: .65;
    }
    @keyframes load { from { background-position: 0 0; } to { background-position: 200% 0; } }
    .hidden { display:none; }
    a.fallback { color:#9cf; }
  </style>
</head>
<body>
  <div id="loader"></div>
  <div id="viewer" aria-label="PDF document"></div>

  <!-- pdf.js (CDN) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.3.136/pdf.min.js"></script>
  <script>
    // Where your PDF lives
    const PDF_URL = 'gender/genderdraft10.23.25.pdf';

    // Set up pdf.js worker
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.3.136/pdf.worker.min.js';

    const viewer = document.getElementById('viewer');
    const loader = document.getElementById('loader');

    // Render a page to a canvas sized for current container width & devicePixelRatio
    async function renderPage(pdf, pageNumber, container) {
      const page = await pdf.getPage(pageNumber);

      // Base viewport at scale=1 to compute width
      const baseViewport = page.getViewport({ scale: 1 });
      const cssWidth = Math.min(container.clientWidth || window.innerWidth, parseInt(getComputedStyle(container).maxWidth)||1e6);

      // Scale so page width fits container width
      const scale = cssWidth / baseViewport.width;

      // Account for device pixel ratio for crisp text
      const dpr = Math.min(window.devicePixelRatio || 1, 2.5); // clamp for perf
      const viewport = page.getViewport({ scale: scale * dpr });

      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d', { alpha: false });
      canvas.width = Math.ceil(viewport.width);
      canvas.height = Math.ceil(viewport.height);
      canvas.style.width = Math.ceil(viewport.width / dpr) + 'px';
      canvas.style.height = Math.ceil(viewport.height / dpr) + 'px';

      const wrap = document.createElement('div');
      wrap.className = 'page';
      wrap.appendChild(canvas);
      container.appendChild(wrap);

      await page.render({ canvasContext: ctx, viewport }).promise;
    }

    // Lazy render pages as they approach viewport (faster on mobile)
    function setupLazyRender(pdf, pageCount, container) {
      const sent = new Array(pageCount + 1).fill(false);

      const sentinel = document.createElement('div');
      sentinel.style.height = '1px';
      container.appendChild(sentinel);

      const io = new IntersectionObserver(async entries => {
        for (const e of entries) {
          if (!e.isIntersecting) continue;

          // Render next not-yet-rendered page near current scroll
          const approxIndex = Math.max(1, Math.round(window.scrollY / (window.innerHeight || 1)) + 1);
          const windowPages = [approxIndex, approxIndex+1, approxIndex+2, approxIndex-1, approxIndex-2];

          for (let p = 1; p <= pageCount; p++) {
            const candidate = windowPages[p-1] || p;
            if (candidate >= 1 && candidate <= pageCount && !sent[candidate]) {
              sent[candidate] = true;
              await renderPage(pdf, candidate, container);
            }
          }
        }
      }, { rootMargin: '200% 0px 200% 0px' });

      io.observe(sentinel);

      // Also kick off first couple pages immediately
      sent[1] = true; renderPage(pdf, 1, container);
      if (pageCount >= 2) { sent[2] = true; renderPage(pdf, 2, container); }
    }

    (async function init() {
      try {
        const pdf = await pdfjsLib.getDocument(PDF_URL).promise;
        setupLazyRender(pdf, pdf.numPages, viewer);

        // Re-render on major resizes/orientation changes: simplest is reload
        let lastW = window.innerWidth, lastH = window.innerHeight;
        addEventListener('orientationchange', () => location.reload());
        addEventListener('resize', () => {
          const w = window.innerWidth, h = window.innerHeight;
          if (Math.abs(w - lastW) > 80 || Math.abs(h - lastH) > 80) location.reload();
          lastW = w; lastH = h;
        });
      } catch (err) {
        console.error(err);
        loader.classList.add('hidden');
        document.body.innerHTML =
          '<div style="padding:16px;max-width:700px;margin:0 auto;color:#fff">' +
          '<p>Could not load the PDF.</p>' +
          `<p><a class="fallback" href="${PDF_URL}">Open the file directly</a>.</p>` +
          '</div>';
        return;
      } finally {
        loader.classList.add('hidden');
      }
    })();
  </script>
</body>
</html>
